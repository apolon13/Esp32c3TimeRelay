## ESP32-C3 Time Relay (Rust)

Небольшой проект на Rust для ESP32-C3, который:
- подключается к Wi‑Fi;
- получает текущее время из интернета (HTTPS, API Ninjas WorldTime);
- запускает задания по расписанию раз в час (пример: включить в 19:00, выключить в 20:00);
- включает базовую инфраструктуру для симуляции в Wokwi.

Проект может служить основой для «умного реле по времени»: вместо `println!("on"/"off")` подключите управление пином реле.

### Возможности
- **Wi‑Fi**: инициализация и подключение с заданными `SSID` и `PASS`.
- **HTTP(S)**: безопасный запрос к внешнему API с использованием системного набора корневых сертификатов ESP‑IDF.
- **Время**: получение и парсинг серверного времени в формате `YYYY-MM-DD HH:MM:SS`.
- **Планировщик**: запуск произвольных колбэков по часовому расписанию с защитой от повторного срабатывания в пределах часа.
- **Симуляция**: конфигурация `wokwi.toml` и `diagram.json` для запуска в Wokwi.

### Архитектура и модули
- `src/main.rs`: точка входа. Настройка логирования, Wi‑Fi, запрос времени, запуск планировщика с задачами.
- `src/network/`
  - `wifi/`
    - `mod.rs`: типы `Credentials` и `Connection`; конфигурация и подключение к сети с помощью ESP‑IDF (`EspWifi`, `BlockingWifi`).
- `src/time/`
  - `remote/`
    - `mod.rs`: HTTP‑клиент и функция `time(...)` для получения и парсинга времени.
    - `model.rs`: модель ответа `NinjasResponse { datetime: String }`.
  - `timer/`
    - `mod.rs`: синхронный таймер `SyncTimer`, вызывающий колбэк каждую секунду, начиная от стартовой метки времени.
- `src/schedule/mod.rs`: планировщик (`Scheduler`), задания (`PeriodicJob`), трейт `Timer`.

Схема взаимодействия: `main` → Wi‑Fi → запрос времени → запуск `Scheduler::run(timer, jobs)` → таймер каждую секунду сообщает текущее время → `Scheduler` в нужный час вызывает `PeriodicJob::run()`.

### Как это работает (пример в `main.rs`)
1. Читаются переменные окружения `SSID`, `PASS`, `API_KEY` (через `dotenv!`).
2. Инициализируется Wi‑Fi соединение и дожидается `netif_up`.
3. Выполняется HTTPS‑запрос к `https://api.api-ninjas.com/v1/worldtime` с заголовком `X-Api-Key: <API_KEY>` и координатами (по умолчанию Москва: `lat=55.751244&lon=37.618423`).
4. Ответ парсится в `NaiveDateTime`.
5. Запускается `Scheduler` с двумя задачами:
   - в 19:00 → `on`;
   - в 20:00 → `off`.

Задачи демонстрационные: замените колбэки на управление GPIO для настоящего реле.

### Требования
- Rust 1.75+ (edition 2021), установленный `rustup`.
- ESP‑IDF и инструменты сборки для Rust (`esp-idf-sys`/`embuild` workflow).
- Целевой таргет: `riscv32imc-esp-espidf` (ESP32‑C3).
- Утилиты прошивки (например, `espflash`) или `idf.py flash` в зависимости от вашего окружения.

В репозитории:
- `rust-toolchain.toml` — фиксирует канал/таргеты.
- `sdkconfig.defaults` — увеличенные стеки задач (важно для HTTPS и логирования).
- `build.rs` — экспорт переменных окружения ESP‑IDF для сборки.

### Переменные окружения
Создайте файл `.env` в корне проекта или задайте переменные через оболочку:

```env
SSID="<имя_вашей_wifi_сети>"
PASS="<пароль_wifi>"
API_KEY="<api_ninjas_key>"
```

API ключ можно получить на сайте `api-ninjas.com` (эндпоинт WorldTime).

### Сборка
Рекомендуемый путь — использовать экосистему `esp-idf` для Rust.

Пример через `cargo` (при настроенном ESP‑IDF toolchain):

```bash
# Установите таргет, если ещё не установлен
rustup target add riscv32imc-esp-espidf

# Сборка (debug)
cargo build

# Сборка под таргет напрямую
cargo build --target riscv32imc-esp-espidf
```

Если используете `cargo-espflash`:

```bash
cargo install cargo-espflash
cargo espflash --target riscv32imc-esp-espidf flash /dev/tty.usbmodemXXXX
```

Либо стандартный `idf.py` (если проект интегрирован в ваше IDF окружение):

```bash
idf.py build
idf.py -p /dev/tty.usbmodemXXXX flash monitor
```

Обратите внимание на путь прошивки и имя последовательного порта под macOS.

### Запуск/поведение
При успешной прошивке и запуске в последовательной консоли вы увидите логи и сообщения `on` / `off` в соответствующие часы. В продакшене замените их на управление реле по GPIO.

### Эмуляция в Wokwi
В репозитории есть:
- `wokwi.toml` — путь к бинарнику/ELF для запуска симуляции;
- `diagram.json` — плата `board-esp32-c3-rust-1` и соединения для просмотра логов.

Запуск из каталога проекта (при наличии Wokwi CLI):

```bash
wokwi-server --http-port 9080
# или через UI Wokwi, указав проектную папку
```

### Расширение под реальное реле
- Замените колбэки в `main.rs` на управление GPIO (например, `esp-idf-hal` → настройка пина как выход и установка уровня HIGH/LOW).
- Добавьте конфигурацию расписания из внешнего источника (NVS/Flash/HTTP) при необходимости.

### Файлы и конфигурация
- `sdkconfig.defaults`:
  - `CONFIG_ESP_MAIN_TASK_STACK_SIZE=20000`
  - `CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096`

Эти значения важны для стабильной работы HTTPS‑клиента и логирования.

### Лицензия
Отсутствует. Добавьте файл `LICENSE`, если планируете распространение.


